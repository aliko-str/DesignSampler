OLD TODO, alread done, but useful as notes: 
	a) // TODO: For dynamic clustering -- Wrap text nodes in spans before clustering, but only if the parent has textual elements <-- different from pure privitive elements <== ATTENTION: Exclude controls/buttons from this - they are primitives


PROTO TODO:

6) Intercept all XHR and disable them before screenshotting

7) Add extra params saved/calculated:
	a) Heuristics to detect/extract semantic elements: login, logo, menu, article, footer, header <-- measure their characteristics too
	b) Media elements
	c) Presense of ads and their parameters
	d) Size and position of images
	e) Grid properties - number and width of columns; cell size; cell profile (e.g., n of images, amount of text, presense of links)


iFrames:

a) Redo all data collection for each iFrame - except some of pageLevel metrics - and combine that with the main data
b) NOTE: most of the scripts should work in iFrames too
c) In scrambling: Send a signal to iFrames to do the scrabling inside <== Also check out how DOM cloning affects iFrames - are they still loaded/rendered after DOM restoration?
d) Save page width - it can be larger than window AND we need this to combine data from iFrames

e) Only evaluate everything in iFrames on a signal from the main window Content Script - otherwise we may suffer from infinite reloads

f) Also look out for weird re-loads of the main window --- Do we unassign handlers after they responded once? (no, we do in tab destruction)





TODO: LATER: replace images from a random collection of images + save a report on what images were used in replacement. <== I don't know yet if the repl. images will be faceless stock photos, or just a re-shuffle of website-sampled images







TODO: LineHeight only makes sense if it's a multi-line piece of text -- else, look at padding and margin ==> DO NOT count for single-line elements.
	SAME for textAlign -- makes no sense for multi-line items
	NOTE: We can't know if an element is surronded by text and how closely --> Use heuristics to reduce error ==> Only measure LineHeight and textAlign for text found in p, span, label, or directly in a div <-- Avoid texts in H, aside



TODO FIX: Line Height is still normal on some pages -- http://www.badmintonindia.org/


FIX: www.indiandancesport.org - replacing div for top image shifts up in position.
NOTE: https://www.aeroclubofindia.com/ -- scrollingElement.scrollWidth is estimated incorrectly in the last FF. <-- Keep an eye on this; If it's too problematic, switch to the previous FF version


TODO: Create all visible collections out of another set: one with bgCol, border; one with only img, txt, and controls


TODO: adjust text column width for the CSS column property + column-gap <== Insert a sub-span; insert <br>; set parents max-width to the current width (so they don't keep expanding with the child); keep adding characters without white spaces; set word-wrap: anywhere on the span; see when the bbox height of the span more than doubles due to a second line added
	NOTE: we should only do this for display: block elements <-- it makes no sense for inline spans <== Get a collection of parent p,div,etc (anything with display block) and measure column width for them
	


TODO: controls with no text nodes, but with text <== to be accounted for: Button, Input:Button, Submit, Cancel, optgroup

TODO: Filter out "ui" graphic elements from scrambling

TODO: Just to be sure, save the text length for each semantic/other group


TODO: Counted "computed/estimated" controls and record some of their properties, but do not use them in WhSpace estimation - they'll screw things up since they'd contain some martings/padding in them <== Only for Page-level descriptions; and to Describe other Semantic elements

TODO: SHOULD we or Shouldn't we both Wrap and Count/Process txtNodes with NO visible characters in them? Some elements use "shadow" text nodes with "\n" in them -- Why count these? <== For now we do, but maybe change later

TODO: LATER (too minor a problem to worry now): <optgroup> label isn't counted as text, no it's possible to wrap it in a span easily




TODO: do caching inside window._getAbsBoundingRectAdjForParentOverflow <== it's heavy and is used a lot
	
TODO: alpha channel in background-image, and also bg size/position/repetition may mess up with WhiteSpace estimation <-- apply blackening only to a reduced pre-computed bbox

TODO: classify graphics/BGs as textures <-- should be a separate category, not to be replaced during Scrambling

TODO: FIX - remove overlays when Computing BgColor


R/LATER TODO:
	a) rework font-sizes - we now just record sizes per text piece
	b) font-family detection  -- we can't know exactly what font was used for what text/character --> just guess that the 1st was used OR use a more complex formulae, with consecutive font-families having lower weights/impacts on the 'computed' page-level fonts (e.g., ratios of serifs to sans-serifs)
	c) Look at the amount of non-generic, custom fonts <== One more metric
	d) For page-level measurement, We should compute BetweenLineSpace based on how many lines of text there actually are...
	e) Use betweenLineSpacing for all element -- when estimating useful whiteSpace -- unless it's blackCharBgAndBtwLines
	f) Computed colorContrast using LAB instead of RGB
	g) FACE detection <-- possible, but a bit too much for js; Do in R: https://www.r-bloggers.com/2019/03/human-face-detection-with-r/
	h) use the best cost-benefit paths <-- it's a measure of design "messiness"
	i) Combined _ids and primitiveType to produce ids for R -- they must be unique

EXTRA TODO: 
		a) Record website structure down to a certain level - render webpages in bg and collect their links
		b) DONE: Collect links: their href, content elements (tags), visible/invisible
		c) use padding/margins and <br> to count useful white space <== <br> not implemented yet -- Count double <br> as useful white space 
		d) TODO: Handle background-repeat:no-repeat, also with background-size and background-position <-- Use these props to adjust BBox down
		e) MINOR TODO: Move non-loaded images from images to text -- if they have 'alt' text to show
		f) // NOTE: we'll skip getClientRects for inline/text elements, and just presume all primites are Rectangles  <== Use getClientRects to get cleaner distances, and avoid sitations when elements appear "nested" (because of multiline inline texts having a BBox enveloping an adjacent small element)
		g) Only remove covering overlay elements that are either primitives or have non-transparent bg?... Otherwise our bgMain vs bgBg detection fails sometimes <-- Only leave coloring overlays if they cover a bg image exactly/fully -- then they are filters; otherwise, they are overlays
		h) Handle text-content pseudo elements <-- both detection and later text sampling <-- save them separately
		i) Placeholders have gray text <-- But we currently record the "color" property, which is not what's shown
		j) Detect pseudo-based bgCol elements <-- I'll only try to whiten them now
		k) Account for several-image banners
		l) Letter replacement sometimes englarges pages -- controls for this and cut back text until height restored??... (or maybe try different reshufflings -- we need to have the same amount of content..)
		m) Collect Emojis as icons <-- now they are text
		n) If an element has "content", count its descendants as invisible <-- I hope I never encounter such idiotic code, but who knows.
		o) Treat box-shadow as borders <-- Require detection (if differs from insides), like borders, and would be used for grouping -- like borders <-- For now we do a quick fix for WhiteSpace counting <-- NOTE: There can be several shadows and They can only wrap an element from 1 or 2 sides
		p) Detach :marker as icons, like I do for :after/:before <-- they can be list-style-image: url("starsolid.gif");
		q) Implement useful-whitespace graphic -- a bit too much for now
		r) Handle nested Iframes <-- Requires nested windowSize adjustment (i.e., communicating in the right order) + Nested frame-window communication
		s) Treat full-screen Iframe as the main frame
		t) Extract JS disabling in separate place, Put it together with animation disabling; Call it before screenshotting
		u) Figure out a solution for SVG pseudo elements scaling with Width, and not up to container <-- I need an image to be an element to get its actual BBox <-- currently keeping it as pseudoelements
		v) Replace images that have src linked to SVG with screenshots <-- the only way to stop animations
		w) Revert style changes to siblings during overlay removal for screenshotting
		x) Extract pseudoElement texts in spans -- for processing <-- it does happen
		y) Make __setCSSPropJqArr more robust to being called several times on the same prop <-- keep a random ID for each call/restoration


TODO: decide if use all primitives as seeds for root search; or just a fraction <-- depending on performance costs

==================================================================================================
NOTE:

// If <a> contains little text and only a small img/icon, count it as a control, otherwise treat it as texst and images; If an <a> is inside a nav/menu/menuitem, it'll already be blacked out, but we should still count these as controls <-- for other estimates

// find all controls + links; process same as images <<== Computed controls should be done after images/text, and restored before images/text <-- because they can contain other primitives in them

 ==================================================================================================
 
 
 TODO NOW:
		
	TODO Tomorrow:
		c) Clear out unused F <-- graphics and element detection in dom.processing.js
		d) https://www.cif-la.org/ --- Figure out why the central logo isn't detected as the main graphic (it's a pseudo element, but I think it still should detect.)